CSCI 5611 - Final Project
Racing Simulator with AI opponents
<h1>John Cullom - cullo006 - 5550513</h1>

<a href="./src/JohnCullomCode.zip" download>Download Code Zip File</a>
<p></p>
<h2>I. Project Overview and Video</h2>

<iframe width=1000 height=800 src="https://www.youtube.com/embed/Yokx_Mwpjoo">
</iframe>
<p>
    This racing simulator combines many of the techniques we learned throughout the course. It combines collision detection, rectangular bounding boxes, normal
    and rotational acceleration, and path planning to build a car racing environment. As seen above, the user races, using the WASD keys, against AI cars that 
    are driven by a PRM built with Uniform Cost Search path planning techniques. The first car to achieve three completed laps wins. There is a GUI that displays
    the time of the user's car, the number of laps completed, and a map of the track and all of the cars on it, with the user indicated with a yellow star. 
</p>
<p>
    The track is built with processing's built-in rectangles and boxes, while the cars are sourced from the Google Drive of free models. Each car has a different
    acceleration, max speed, width, and length. The collisions between the cars and walls are a scaled-back version of the rigid body activity in class. It does not
    adjust any rotational aspects of the car's motion, only the position and velocity. The PRM model was built with the same framework as the one from project 1, 
    utilizing a priority-queue frontier that searches all possible paths until it's empty. The motion and collisions are all built in 2D, with the simulation being 
    rendered in 3D.
    
</p>
<p>
    The racer must press the space bar after the game loads to start it. After the user finishes the third lap, they can keep racing around the track as much as they
    would like, but the game is effectively "over". The AI cars will continue to race even after the game ends, as they are looping around the track along their 
    PRM-generated path. There is a shortcut that can be seen on the map that the AI cars can not take. This gives the user the ability to win the race even if 
    they have the slowest car in the game. The wall collisions are very bouncey and the shortcut is very narrow, so the user must hit the shortcut perfectly to
    gain an advantage. 
</p>

<h2>II. Key Algorithms and Methods</h2>
<p>
    As mentioned earlier, the racing game is built using a combination of different topics discussed in class. Many of the techniques are modified to be either
    simpler or computationally faster, almost in a hacky way. 
</p>
<h4>i. Collisions</h4>
<p>
    The game is driven by both car-to-car and car-to-wall collisions. While both are driven by rectangular bounding box logic, there collisions are generated in 
    different ways. The initial collision checking was done by seeing if any of the four lines generated by the four corners of each car intersected any of the four
    lines generated by the four corners of each obstacle. If there was an intersection of the lines, the collision checking method would return the index of the obstacle
    or car that the car currently being checked collided with, and the car was "bounced" off of the object by subtracting the positions. This didn't seem very natural, as
    the bounce after hitting a wall depended on the center of the wall object, rather than the angle of the car with respect to the wall's normal. This technique is still in
    use for determining the collisions between cars since it doesn't appear glitchy or unnatural.
</p>
<p>
    The collisions between the walls and the cars are now determined by looking at the four corners of each car and seeing if they are inside any of the wall objects.
    If so, the car is bounced off based on which corners were inside the wall.
</p>
<img height=200 width="auto" src="./images/wallCollisions.JPG">
<p>
    As seen in the picture above, with nodes 3 or 4 colliding with the wall the car's velocity would be set to the normal of the opposite face of the car. This was a large
    upgrade from the previous method of collision resolution because the car bounces sideways, not backwards awkwardly. Ideally, rigid bodies would resolve collisions
    the best, but rotational motion was not factored into the collisions and the math behind rigid body collisions of two moving objects with rotation seemed like a steep
    mountain to implement that wasn't necessary. The current adaptation works decently well and does not cause cars to get stuck on walls. 
</p>

<h4>ii. PRM and Uniform Cost Search</h4>
<p>
    The AI cars move based on pathways that are generated from a Probabilistic Roadmap (PRM) implementation. The PRM builds this pathway by generating 500 random nodes 
    on the map, connecting these nodes, then finding a path through the connections from designated start and end positions. The start positions of the paths are the cars'
    starting positions before the race begins, and the end point is 30 Processing Units behind the inside-most car. There is an invisible obstacle between the start and end
    positions so that the PRM does not simply build a straight line from start to end. The 500 randomly generated nodes are generated in a way so they are not inside any
    wall obstacles. Once the nodes are all connected, the PRM builds a priority queue of all the nodes that can see the starting position. The priority queue then checks
    each node individually, ordered by lowest distance from the start, seeing if it can reach the goal position and adding the node's neighbors if it can't. Once the 
    priority queue finds a node that can access the goal position, it will see if the connected path of neighbors is the shortest goal path found. The priority queue 
    will remove any nodes that have a distance that is larger than the found goal distance to save runtime. At the end, the shortest found path is a string of
    nodes that represent the path from start to finish for that car. 

</p>

<p>
    In car movement, the AI cars move from node-to-node, keeping track of which node is next on their list to visit. There is path smoothing implemented, that allows
    the car to move past the desired node once it can see the node after it on the path. Once the cars get to the last node in the path, the path resets to target the first
    node in the path. It's at this point that the car "completed" a lap.
</p>

<h4>iii. Car Movement</h4>
<p>
    Each car's movement is determined by its physics and rotational physics. Rotational acceleration and normal acceleration determine their respective velocities, and
    these determine their respective position updates. The car rotates toward the position of the next desired node. See the code snippit below to see
    the calculations that determine the movement. Velocity is preserved from timestep to timestep and is influenced by an acceleration vector that is generated based on 
    the current rotation of the car. 
</p>
<img height=120 width="auto" src="./images/carMotion.JPG">

<p>
    The user controlls the car with the WASD keys. The car can only rotate if W or S is down. When A or D is down, the rotational aceleration is set to a nonzero number
    to match which direction the car is to rotate. The AI cars rotation is determined by the algorithm shown below, found on a StackExchange post. This was a large 
    issue in developing the AI car movement, as they kept rotating the wrong way for different desired angles. This was solved by adding 180 to the desired angle then 
    setting the angle equal to the modulus of the angle at the end. 
</p>
<img height=240 width="auto" src="./images/AIRotations.JPG">
<p>
    The user can only complete a lap after their car has passed the starting line AND been inside a zone on the opposite side of the map. This is to keep users from
    cheating the game and doing circles at the starting line to gain laps. See the images below for a map view of the two zones, as well as the code that controlls 
    lap incrementation for the user's car.
</p>
<img height=240 width="auto" src="./images/mapForUserLaps.JPG">
<img height=240 width="auto" src="./images/userLaps.JPG">

<h2>III. Video Game Aspects</h2>

<h2>IV. Progression of Work</h2>

<h2>V. Peer Feedback</h2>

<h2>VI. Related Work</h2>

<h2>VII. Future Work</h2>
