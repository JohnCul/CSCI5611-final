CSCI 5611 - Final Project
Racing Simulator with AI opponents
<h1>John Cullom - cullo006 - 5550513</h1>

<a href="./src/JohnCullomCode.zip" download>Download Code Zip File</a>
<p></p>
<h2>I. Project Overview and Video</h2>

<iframe width=1200 height=900 src="https://www.youtube.com/embed/Yokx_Mwpjoo">
</iframe>
<p>
    This racing simulator combines many of the techniques we learned throughout the course. It combines collision detection, rectangular bounding boxes, normal
    and rotational acceleration, and path planning to build a car racing environment. As seen above, the user races, using the WASD keys, against AI cars that 
    are driven by a PRM built with Uniform Cost Search path planning techniques. The first car to achieve three completed laps wins. There is a GUI that displays
    the time of the user's car, the number of laps completed, and a map of the track and all of the cars on it, with the user indicated with a yellow star. 
</p>
<p>
    The track is built with processing's built-in rectangles and boxes, while the cars are sourced from the Google Drive of free models. Each car has a different
    acceleration, max speed, width, and length. The collisions between the cars and walls are a scaled-back version of the rigid body activity in class. It does not
    adjust any rotational aspects of the car's motion, only the position and velocity. The PRM model was built with the same framework as the one from project 1, 
    utilizing a priority-queue frontier that searches all possible paths until it's empty. The motion and collisions are all built in 2D, with the simulation being 
    rendered in 3D.
    
</p>
<p>
    The racer must press the space bar after the game loads to start it. After the user finishes the third lap, they can keep racing around the track as much as they
    would like, but the game is effectively "over". The AI cars will continue to race even after the game ends, as they are looping around the track along their 
    PRM-generated path. There is a shortcut that can be seen on the map that the AI cars can not take. This gives the user the ability to win the race even if 
    they have the slowest car in the game. The wall collisions are very bouncey and the shortcut is very narrow, so the user must hit the shortcut perfectly to
    gain an advantage. 
</p>

<h2>II. Key Algorithms and Methods</h2>
<p>
    As mentioned earlier, the racing game is built using a combination of different topics discussed in class. Many of the techniques are modified to be either
    simpler or computationally faster, almost in a hacky way. 
</p>
<h4>i. Collisions</h4>
<p>
    The game is driven by both car-to-car and car-to-wall collisions. While both are driven by rectangular bounding box logic, there collisions are generated in 
    different ways. The initial collision checking was done by seeing if any of the four lines generated by the four corners of each car intersected any of the four
    lines generated by the four corners of each obstacle. If there was an intersection of the lines, the collision checking method would return the index of the obstacle
    or car that the car currently being checked collided with, and the car was "bounced" off of the object by subtracting the positions. This didn't seem very natural, as
    the bounce after hitting a wall depended on the center of the wall object, rather than the angle of the car with respect to the wall's normal. This technique is still in
    use for determining the collisions between cars since it doesn't appear glitchy or unnatural.
</p>
<p>
    The collisions between the walls and the cars are now determined by looking at the four corners of each car and seeing if they are inside any of the wall objects.
    If so, the car is bounced off based on which corners were inside the wall.
</p>
<img height=200 width="auto" src="./images/wallCollisions.JPG">
<p>
    As seen in the picture above, with nodes 3 or 4 colliding with the wall the car's velocity would be set to the normal of the opposite face of the car. This was a large
    upgrade from the previous method of collision resolution because the car bounces sideways, not backwards awkwardly. Ideally, rigid bodies would resolve collisions
    the best, but rotational motion was not factored into the collisions and the math behind rigid body collisions of two moving objects with rotation seemed like a steep
    mountain to implement that wasn't necessary. The current adaptation works decently well and does not cause cars to get stuck on walls. 
</p>

<h4>ii. PRM and Uniform Cost Search</h4>
<p>
    The AI cars move based on pathways that are generated from a Probabilistic Roadmap (PRM) implementation. The PRM builds this pathway by generating 500 random nodes 
    on the map, connecting these nodes, then finding a path through the connections from designated start and end positions. The start positions of the paths are the cars'
    starting positions before the race begins, and the end point is 30 Processing Units behind the inside-most car. There is an invisible obstacle between the start and end
    positions so that the PRM does not simply build a straight line from start to end. The 500 randomly generated nodes are generated in a way so they are not inside any
    wall obstacles. Once the nodes are all connected, the PRM builds a priority queue of all the nodes that can see the starting position. The priority queue then checks
    each node individually, ordered by lowest distance from the start, seeing if it can reach the goal position and adding the node's neighbors if it can't. Once the 
    priority queue finds a node that can access the goal position, it will see if the connected path of neighbors is the shortest goal path found. The priority queue 
    will remove any nodes that have a distance that is larger than the found goal distance to save runtime. At the end, the shortest found path is a string of
    nodes that represent the path from start to finish for that car. 

</p>

<p>
    In car movement, the AI cars move from node-to-node, keeping track of which node is next on their list to visit. There is path smoothing implemented, that allows
    the car to move past the desired node once it can see the node after it on the path. Once the cars get to the last node in the path, the path resets to target the first
    node in the path. It's at this point that the car "completed" a lap.
</p>

<h4>iii. Car Movement</h4>
<p>
    Each car's movement is determined by its physics and rotational physics. Rotational acceleration and normal acceleration determine their respective velocities, and
    these determine their respective position updates. The car rotates toward the position of the next desired node. See the code snippit below to see
    the calculations that determine the movement. Velocity is preserved from timestep to timestep and is influenced by an acceleration vector that is generated based on 
    the current rotation of the car. 
</p>
<img height=120 width="auto" src="./images/carMotion.JPG">

<p>
    The user controlls the car with the WASD keys. The car can only rotate if W or S is down. When A or D is down, the rotational aceleration is set to a nonzero number
    to match which direction the car is to rotate. The AI cars rotation is determined by the algorithm shown below, found on a StackExchange post. This was a large 
    issue in developing the AI car movement, as they kept rotating the wrong way for different desired angles. This was solved by adding 180 to the desired angle then 
    setting the angle equal to the modulus of the angle at the end. 
</p>
<img height=240 width="auto" src="./images/AIRotations.JPG">
<p>
    The user can only complete a lap after their car has passed the starting line AND been inside a zone on the opposite side of the map. This is to keep users from
    cheating the game and doing circles at the starting line to gain laps. See the images below for a map view of the two zones, as well as the code that controlls 
    lap incrementation for the user's car.
</p>
<img height=240 width="auto" src="./images/mapForUserLaps.JPG">
<img height=240 width="auto" src="./images/userLaps.JPG">




<h2>III. Video Game Aspects</h2>
<p>
    This game obviously isn't an original idea. It was initially targeted to be based off of Mario Kart, but designing a full Mario Kart map would take months to 
    create and perfect. Implementing item boxes presents a similar challenge that entails much more details and issues than imagined. The reason this game idea was
    chosen was that it used so many topics from class, as explained in section II, and combined them into a working simulation that is often seen in the video game industry. 
</p>

<p>
    The AI cars use paths that are generated at the start of the program. This is done because the algorithm itself takes a while to generate each pathway. However,
    it was first imagined that the cars would change their paths in real time, generating a new path to traverse every few timesteps. This would've been a simpler version
    of Sigurdson and Bulitko's state-of-the-art tehcnique of using deep learning to choose which real-time path planning algorithm works best in certain situations.
    Utilizing a version of this would allow the AI cars to plan different pathways with different lengths when they were in different circumstances within the game. 
    This wouldn't be realistic to implement unless the network was already learned with test data and results before the simulation began. 
</p>

<p>
    The gameplay with designed with 2D movement because it makes all the small parts of the simulation--path planning, collisions, model placement--infinitely less 
    complicated and cumbersome. The simulation focused on tuning car movement and interraction, keeping the cars in a plain enviornment with good visibility and
    navigability. 
</p>

<h2>IV. Progression of Work</h2>
<p>
    I started with building the basic layout of the map. Then I put one large obstacle in the middle and tried to get the PRM system working for the AI cars. Below is a
    gif of the progress from that phase of the project.
</p>
<img height=300 width="auto" src="./images/progress1gif.gif">
<img height=300 width="auto" src="./images/progress2gif.gif">
<p>
    Initially the car movement was not based on normal physics. There was no rotational acceleration or positional acceleration, and the car movement didn't look realistic.
    After implementing the current physics and changing the size of the car models, I began to construct the current course. Building the maze with wall objects was not 
    difficult but was time consuming. It was guess and check for every object. I expected to be able to add more creativity into the walls, adding textures and models instead
    of plain blue walls, but I ran into the issue of adding pictures into the simulation. I could not get anything to load properly, so I decided to focus my efforts on 
    implementing collisions.
</p>
<p>
    Part of determining AI movememnt was figuring out the angles and rotational motion of the cars. One of the most difficult parts of the project was finding out the logic
    behind the desired Angle and findDifference function. It was a headache trying to figure out which angles and offsets were needed to make it work, and was incredibly 
    satisfying when it finally worked.
</p>
<p>
    Collisions were the hardest and most time consuming part of the project. I looked online at different methods for implementing bounding box collisions, and found
    the line intersection idea that was outlined in Section II. This method was effective in determining that there was a collision, but it didn't give me enough information
    to resolve the collision in a graceful way. I then thought of a second way of detecting collisions that would provide more information about what direction to move the
    car in. Since the cars are boxes, the only way they collide with a wall is if one of the four corners of the rectangle goes inside one of the walls. I used this to 
    create a PointInBox approach to detecting wall-car collisions, returning the integer of the corner that is colliding with the wall. Having this information, the direction
    of collision resolution can be found because it will be opposite of the side that the colliding corner was on. This can also be seen in the image in Section II.
</p>
<p>
    After implementing collisions, I built the GUI. This was the last large major part of the simulation, and again was mostly guess-and-check work. Getting the GUI to 
    face the car was the most difficult aspect, finding out how much to rotate and when to rotate, translate, and use the hint() function. The GUI is strange because
    if the camera was in any other spot, you could see the GUI moving with the car in space. It is not glued to the user's screen, but floating above the car somewhere in space. 

</p>

<h2>V. Peer Feedback</h2>
<p>

</p>

<h2>VI. Related Work</h2>

<h2>VII. Future Work</h2>
